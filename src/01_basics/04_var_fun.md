### 1. 变量（Variables）
Rust 中的变量默认是不可变的（immutable），这有助于避免意外修改数据，提高代码安全性。变量使用 `let` 关键字声明。

- **声明和不可变性**：默认情况下，变量一旦赋值就不能改变。如果尝试修改，会在编译时出错。
  示例：
  ```rust
  fn main() {
      let x = 5;
      // x = 6; // 错误：cannot assign twice to immutable variable
      println!("x 的值为: {}", x);
  }
  ```

- **可变性（Mutability）**：使用 `mut` 关键字使变量可变，可以多次赋值。
  示例：
  ```rust
  fn main() {
      let mut x = 5;
      println!("x 的值为: {}", x);
      x = 6;
      println!("x 的值为: {}", x);
  }
  ```
  注意：可变性是可选的，用于表示变量可能在未来变化。

- **常量（Constants）**：使用 `const` 声明，常量总是不可变的，必须指定类型，且值必须是常量表达式（编译时计算）。常量可以全局声明。
  示例：
  ```rust
  const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

  fn main() {
      println!("三小时的秒数: {}", THREE_HOURS_IN_SECONDS);
  }
  ```

- **遮蔽（Shadowing）**：可以使用相同的变量名重新声明（用 `let`），新变量会“遮蔽”旧的。这允许类型转换，而不需使用 `mut`，且防止意外修改。
  示例：
  ```rust
  fn main() {
      let x = 5;
      let x = x + 1; // 遮蔽，x 现在是 6

      {
          let x = x * 2; // 内作用域遮蔽，x 是 12
          println!("内层 x 的值为: {}", x);
      }

      println!("外层 x 的值为: {}", x); // 打印 6
  }
  ```
  注意：遮蔽不同于可变性，它允许改变类型（例如从字符串到数字）。

变量的作用域是块级（用 `{}` 包围），超出作用域后变量被销毁。

### 2. 基本类型（Basic Types）
Rust 是静态类型语言，编译时必须知道所有变量的类型，但支持类型推断（type inference）。基本类型分为标量类型（scalar）和复合类型（compound）。

#### 标量类型（Scalar Types）
这些类型表示单个值。

- **整数（Integers）**：无小数部分，分有符号（`i`）和无符号（`u`），不同位宽。默认是 `i32`。
  | 类型     | 有符号范围示例（i8） | 无符号范围示例（u8） | 示例 |
  |----------|----------------------|----------------------|------|
  | 8-bit   | -128 到 127         | 0 到 255            | `let x: i8 = -10;` |
  | 16-bit  | -32768 到 32767     | 0 到 65535          | `let y: u16 = 1000;` |
  | 32-bit  | -2^31 到 2^31-1     | 0 到 2^32-1         | `let z = 42; // i32 默认` |
  | 64-bit  | -2^63 到 2^63-1     | 0 到 2^64-1         | `let a: i64 = 999999999999;` |
  | 128-bit | -2^127 到 2^127-1   | 0 到 2^128-1        | `let b: u128 = 1;` |
  | isize/usize | 依赖架构（64-bit 系统为 64 位） | 同左 | 用于索引 |

  字面量示例：十进制 `98_222`、十六进制 `0xff`、八进制 `0o77`、二进制 `0b1111_0000`、字节 `b'A'`（仅 `u8`）。
  注意：整数溢出在调试模式会 panic，在发布模式会环绕（two’s complement）。使用 `wrapping_add` 等方法处理溢出。

- **浮点数（Floating-Point Numbers）**：有小数部分，默认 `f64`（更高精度）。
  示例：
  ```rust
  fn main() {
      let x = 2.0; // f64
      let y: f32 = 3.0; // f32
      println!("x: {}, y: {}", x, y);
  }
  ```
  注意：符合 IEEE-754 标准。

- **布尔（Booleans）**：`true` 或 `false`，大小 1 字节，用于条件判断。
  示例：
  ```rust
  fn main() {
      let t = true;
      let f: bool = false;
      if t {
          println!("真");
      }
  }
  ```

- **字符（Characters）**：用单引号表示，4 字节，支持 Unicode（包括表情符号）。
  示例：
  ```rust
  fn main() {
      let c = 'z';
      let z: char = 'ℤ';
      let heart_eyed_cat = '😻';
      println!("字符: {}", heart_eyed_cat);
  }
  ```
  注意：不同于字符串（双引号），`char` 是 Unicode 标量值。

#### 复合类型（Compound Types）
这些类型组合多个值。

- **元组（Tuples）**：固定长度，允许不同类型。访问用点号或解构。
  示例：
  ```rust
  fn main() {
      let tup: (i32, f64, u8) = (500, 6.4, 1);
      let (x, y, z) = tup; // 解构
      println!("y 的值为: {}", y);
      let five_hundred = tup.0; // 索引访问
  }
  ```
  注意：空元组 `()` 表示无值，常用于无返回值的函数。

- **数组（Arrays）**：固定长度，所有元素同类型，栈上分配。
  示例：
  ```rust
  fn main() {
      let a: [i32; 5] = [1, 2, 3, 4, 5];
      let b = [3; 5]; // [3, 3, 3, 3, 3]
      println!("第一个元素: {}", a[0]);
  }
  ```
  注意：长度固定，不能增长。越界访问会 panic。

### 3. 函数（Functions）
Rust 函数使用 `fn` 关键字定义，使用 snake_case 命名（小写下划线分隔）。函数可以有参数、返回值的声明，且顺序不影响调用（只要在作用域内）。

- **定义和调用**：函数体用 `{}` 包围，调用用函数名加 `()`。
  示例：
  ```rust
  fn main() {
      println!("Hello, world!");
      another_function();
  }

  fn another_function() {
      println!("另一个函数。");
  }
  ```

- **参数（Parameters）**：必须声明类型，多参数用逗号分隔。
  示例：
  ```rust
  fn main() {
      print_labeled_measurement(5, 'h');
  }

  fn print_labeled_measurement(value: i32, unit_label: char) {
      println!("测量值为: {value}{unit_label}");
  }
  ```

- **语句 vs 表达式**：语句不返回值（以 `;` 结束），表达式返回值（无 `;`）。函数体可由语句组成，最后表达式作为返回值。
  注意：块 `{}` 也是表达式。

- **返回值（Return Values）**：用 `->` 指定类型，最后表达式（无 `;`）即返回值，也可用 `return` 提前返回。
  示例：
  ```rust
  fn main() {
      let x = plus_one(5);
      println!("x 的值为: {}", x);
  }

  fn plus_one(x: i32) -> i32 {
      x + 1  // 无分号，返回值
  }
  ```

更多细节可参考 Rust 官方书籍：https://doc.rust-lang.org/book 

# 补充知识
## 补充知识一、let 变量不初始化的情况
非常好的问题，这个细节在 Rust 中非常关键 👍。我们来一步步解释。

---

### 🧩 一、`let x;` 在 Rust 中是否可行？

🚫 **不行。**
Rust 要求**所有变量在使用前必须初始化**，即必须有一个确定的值。
所以这段代码会直接编译错误：

```rust
fn main() {
    let x; // ❌ 错误：使用前未初始化
    println!("{}", x);
}
```

错误信息会类似：

```
error[E0381]: used binding `x` is possibly-uninitialized
```

Rust 的设计目标之一是**消除未初始化变量造成的未定义行为（UB）**。

---

### ✅ 二、那我能不能“先声明，后赋值”？

可以，但你**必须保证赋值在使用前完成**。例如：

```rust
fn main() {
    let x;
    x = 5; // ✅ 在使用前完成初始化
    println!("{}", x);
}
```

✅ 这段是合法的。Rust 编译器可以在编译时推断出 `x` 在被使用前已经被赋值，因此通过。

---

### 🧠 三、Rust 变量没有“默认值”

Rust 不会自动给变量赋默认值（不像 C++ 或 Python 那样）。
**如果你想要一个默认值，必须显式写出来。**

例如：

```rust
let x = 0;        // 整型默认用 0
let s = String::new(); // 字符串默认空
let v = Vec::new();    // 向量默认空
```

---

### 🧰 四、那如果我想定义一个变量稍后才能确定值呢？

可以用 `mut` 可变变量：

```rust
fn main() {
    let mut x;
    x = 42; // ✅ 允许后赋值
    x = 100; // ✅ 可重复赋值
    println!("{}", x);
}
```

> 注意：`mut` 表示“变量的绑定是可变的”，并不是说可以先不赋值。仍然必须保证在使用前初始化。

---

### 🧩 五、总结

| 情况                                 | 是否可行 | 说明       |
| ---------------------------------- | ---- | -------- |
| `let x;`                           | ❌    | 未初始化     |
| `let x; x = 5; println!("{}", x);` | ✅    | 初始化后再使用  |
| `let x = 5;`                       | ✅    | 直接初始化    |
| `let mut x = 5; x = 6;`            | ✅    | 可重新赋值    |
| `let mut x; println!("{}", x);`    | ❌    | 使用前必须初始化 |

---

要不要我接下来帮你解释一下 **“为什么 Rust 不自动赋默认值”**（涉及到内存安全模型和零成本抽象的理念）？这背后其实是 Rust 语言设计哲学的核心之一。

## 补充知识二、const 声明时，可以写在方法里吗
非常棒的问题，这个细节在 Rust 中和其他语言（比如 Java、C++）确实不太一样。我们来精确讲解。

---

## 🧩 一、结论：

✅ **可以在函数（方法）里写 `const` 声明。**
但有一些 **重要限制**。

---

## 🧠 二、语法示例：

```rust
fn main() {
    const PI: f64 = 3.14159; // ✅ 可以定义在函数内部
    println!("PI = {}", PI);
}
```

✅ 编译通过。

---

## 📘 三、规则与限制：

| 特性             | 说明                                |
| -------------- | --------------------------------- |
| **必须在声明时初始化**  | `const` 不允许延迟赋值，必须有确定的编译期常量值      |
| **类型必须显式写出**   | Rust 编译器无法自动推断 `const` 的类型        |
| **值必须在编译期可确定** | 不能用运行时计算的值，比如函数调用结果或变量            |
| **作用域**        | 如果写在函数里，只在该函数内部可见；如果写在函数外部，则为全局常量 |

---

## 🧩 四、对比：`const` vs `let` vs `static`

| 关键字      | 是否可变       | 是否编译期常量 | 是否分配在堆/静态区  | 可否写在函数内    |
| -------- | ---------- | ------- | ----------- | ---------- |
| `let`    | ✅ 可用 `mut` | ❌ 否     | 栈上          | ✅          |
| `const`  | ❌ 不可变      | ✅ 是     | 编译时内联，无存储空间 | ✅          |
| `static` | ✅ 可用 `mut` | ✅ 是     | 静态存储区（全局）   | ⚠️ 不能写在函数里 |

---

## 🚫 五、错误示例（运行时值不能用于 const）

```rust
fn main() {
    let x = 10;
    const Y: i32 = x; // ❌ 错误：x 不是编译期常量
    println!("{}", Y);
}
```

错误信息：

```
error[E0435]: attempt to use a non-constant value in a constant
```

---

## ✅ 六、正确写法（编译期常量）

```rust
fn main() {
    const X: i32 = 10;
    const DOUBLE_X: i32 = X * 2; // ✅ 编译期计算
    println!("{}", DOUBLE_X);
}
```

---

## 📘 七、常见使用场景：

```rust
impl Circle {
    const PI: f64 = 3.14159; // ✅ 定义在 impl 内部
    fn area(r: f64) -> f64 {
        Self::PI * r * r
    }
}
```

---

### ✅ 小结

| 问题                  | 答案    |
| ------------------- | ----- |
| 可以在函数里定义 `const` 吗？ | ✅ 可以  |
| 需要类型注解吗？            | ✅ 必须写 |
| 可以用运行时值吗？           | ❌ 不行  |
| 可以用在 `impl` 或模块中吗？  | ✅ 可以  |

---

是否要我下一步帮你讲讲 `const` 和 `static` 在**内存分布**上的区别？（它们一个会被内联，一个分配在静态区）这部分是理解 Rust 常量机制的关键。

## 补充知识三、const声明的变量，可以先声明，再赋值吗
非常好的问题！💯
Rust 对 `const` 的规则非常严格，这正体现了它的「**编译期确定性**」和「**内存安全设计**」。

---

## 🧩 一、结论

🚫 **不可以。**

`const` 常量在 Rust 中 **必须在声明时初始化**，不能先声明、再赋值。
也就是说，下面这种写法是错误的：

```rust
fn main() {
    const X: i32; // ❌ 错误：常量必须初始化
    X = 10;
    println!("{}", X);
}
```

编译器会报错：

```
error[E0010]: constants cannot be left uninitialized
```

---

## ✅ 二、正确写法

你必须在声明的同时赋值：

```rust
fn main() {
    const X: i32 = 10; // ✅ 正确：编译期常量
    println!("{}", X);
}
```

---

## 🧠 三、原因解析：

Rust 的 `const` 常量和运行时变量 (`let`) 完全不同。

| 特性        | `const`   | `let`         |
| --------- | --------- | ------------- |
| 值的确定时间    | 编译期       | 运行期           |
| 是否需要立即初始化 | ✅ 是       | ❌ 否（可稍后赋值）    |
| 存储位置      | 无固定存储（内联） | 栈上（或堆上间接引用）   |
| 可否重新赋值    | ❌ 不可      | ✅ 若使用 `mut` 可 |

Rust 的 `const` **不会在运行时分配内存**，编译器会在编译阶段直接用它的值进行替换（称为 *inlining*）。
所以它必须在编译时就完全确定值，不能等到运行时再赋。

---

## 📘 四、延伸：编译期可计算的表达式

`const` 可以用编译器能推导出的表达式：

```rust
const A: i32 = 2;
const B: i32 = A * 3;     // ✅ 编译期计算
const MESSAGE: &str = "Hello"; // ✅ 字符串常量
```

但不可以使用运行时值：

```rust
fn main() {
    let n = 5;
    const X: i32 = n + 1; // ❌ 错误：n 是运行时值
}
```

---

## ✅ 五、总结表

| 操作                                | 是否允许 | 说明        |
| --------------------------------- | ---- | --------- |
| `const X: i32;`                   | ❌    | 必须初始化     |
| `const X: i32 = 5;`               | ✅    | 编译期常量     |
| `const X: i32 = other_const * 2;` | ✅    | 只要依赖的也是常量 |
| `const X: i32 = some_function();` | ❌    | 运行时计算不行   |

---

是否希望我下一步帮你讲解 Rust 中「`const fn`（常量函数）」？
它允许你定义能在编译期被求值的函数，用来生成常量值。这个是 `const` 的高级用法，非常实用。
